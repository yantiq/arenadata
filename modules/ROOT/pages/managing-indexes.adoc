= Управление индексами

Существует два способа индексации данных в OpenSearch с помощью REST API:

`index API` — подходит, когда данные поступают по-очереди (например, заказы клиентов для малого бизнеса).
В этом случае документы добавляются по одному.

`_bulk API` — используется для пакетной индексации, что обеспечивает лучшую производительность при обработке большого количества данных.

Если документы слишком объемные, их придется индексировать по отдельности.

[NOTE]
====
При индексации документов их идентификатор `_id` не должен превышать 512 байтов.
====

== Введение в индексацию

Перед поиском данные необходимо проиндексировать.
Индексация — это процесс организации данных, благодаря которому поиск становится быстрым и эффективным.
В OpenSearch данные хранятся в виде JSON-документов, и каждый документ получает уникальный идентификатор внутри индекса.

Пример API запроса:

[source,sh]
----
PUT <index>/_doc/<id>
{ "A JSON": "document" }
----

Пример запроса `_bulk API`:

[source,sh]
----
POST _bulk
{ "index": { "_index": "<index>", "_id": "<id>" } }
{ "A JSON": "document" }
----

=== Формат данных для `_bulk API`

Данные должны быть в определенном формате: каждая строка заканчивается символом новой строки (`\n`).
```
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
```

[NOTE]
====
Для операции `delete` документ не является обязательным.
Для `index`, `create` и `update` документ обязателен.
Используйте `create` вместо `index`, чтобы не допустить перезапись существующего документа.
====
Чтобы загрузить bulk-данные через `curl`, перейдите в папку, где сохранен ваш файл, выполните команду:

```sh
curl -H "Content-Type: application/x-ndjson" -POST https://localhost:9200/data/_bulk -u 'admin:admin' --insecure --data-binary "@data.json"
```

Если одна из операций в `_bulk API` завершится ошибкой, OpenSearch продолжит выполнение остальных операций.
Проверьте `items`, чтобы выяснить причину ошибки.

=== Автоматическое создание индекса

OpenSearch создаст индекс автоматически при добавлении первого документа. Также автоматически генерируется ID, если его не указать.
ID можно указать отдельно.

Пример автоматического создания индекса `movies`:

```sh
POST movies/_doc
{ "title": "Spirited Away" }
```

Если ID не указан, документ сложно обновить в будущем, а при повторном выполнении запроса создаются дубликаты.

Пример указания ID `1`:

[NOTE]
====
Используйте `PUT` вместо `POST`
====

```sh
PUT movies/_doc/1
{ "title": "Spirited Away" }
```

Если запрос выполнить 10 раз, сохранится один документ, а его поле `_version` увеличится до 10.

=== Настройки шардирования и репликации

По умолчанию у индекса 1 основной шард и 1 реплика.
Чтобы задать другие параметры, создайте индекс перед добавлением данных:

```sh
PUT more-movies
{ "settings": { "number_of_shards": 6, "number_of_replicas": 2 } }
```

=== Ограничения наименования индексов

OpenSearch накладывает следующие ограничения на названия индексов:

- Все буквы должны быть в нижнем регистре.
- Название индекса не может начинаться с `_` или `-`.
- Название индекса не может содержать пробелы, запятые и следующие символы: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`.

== Чтение данных

Чтобы получить документ по ID, выполните GET-запрос:

[source,sh]
----
GET movies/_doc/1
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Spirited Away"
  }
}
----

Ответ содержит документ в объекте `_source`.
Если документ отсутствует, поле `found` будет *false*.
Для получения нескольких документов используйте `_mget`:

[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>"
    },
    {
      "_index": "<index>",
      "_id": "<id>"
    }
  ]
}
----

Чтобы вернуть только определенные поля в документе:

[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field1"
    },
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field2"
    }
  ]
}
----

Чтобы проверить существование документа:

[source,sh]
----
HEAD movies/_doc/<doc-id>
----
Если документ существует, вернётся `200 OK`, иначе `404 Not Found`.

== Обновление данных

Частичное обновление документа выполняется с помощью `_update`:

[source,sh]
----
POST movies/_update/1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Обратите внимание на обновленное поле названия и новое поле жанра:
[source,sh]
----
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 2,
  "_seq_no" : 1,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Castle in the Sky",
    "genre" : [
      "Animation",
      "Fantasy"
    ]
  }
}
----
Документ также имеет увеличенное поле `_version`.
Используйте это поле, чтобы отслеживать, сколько раз обновлялся документ.

Полное обновление документа выполняется PUT-запросом:
[source,sh]
----
PUT movies/_doc/1
{ 
  "title": "Spirited Away" 
}
----
Документ с идентификатором 1 будет содержать только поле `title``, поскольку весь документ будет заменен на документ, индексированный в этом запросе PUT.

Если документ отсутствует, его можно создать с помощью `upsert`:
Если документ существует, его поле `title` меняется на `Castle in the Sky`.
Если нет, OpenSearch индексирует документ в `upsert`.

[source,sh]
----
POST movies/_update/2
{
  "doc": {
    "title": "Castle in the Sky"
  },
  "upsert": {
    "title": "Only Yesterday",
    "genre": ["Animation", "Fantasy"],
    "date": 1993
  }
}
----
==== Пример ответа

[source,sh]
----
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "2",
  "_version" : 2,
  "result" : "updated",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 3,
  "_primary_term" : 1
}
----

Каждая операция по обновлению документа имеет уникальную комбинацию значений `_seq_no` и `_primary_term`.

OpenSearch сначала обновляет данные в основном шарде, а затем отправляет изменения на все реплики.

Проблема может возникнуть, если несколько пользователей одновременно редактируют один и тот же документ.
В этом случае один пользователь может получить версию документа из реплики, которая еще не обновилась, и внести в нее изменения.

В итоге его обновление перезапишет данные, которые уже изменил другой пользователь, что может привести к потере актуальной информации.

Чтобы избежать таких конфликтов, используйте параметры `_seq_no` и `_primary_term` в заголовке запроса.

[source,sh]
----
POST movies/_update/2?if_seq_no=3&if_primary_term=1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Если документ был изменен после того, как вы его получили, значения `_seq_no` и `_primary_term` будут отличаться.
В этом случае попытка обновления приведет к ошибке 409 — `conflict`.

При использовании API `_bulk` указывайте `_seq_no` и `_primary_term` в метаданных запроса, чтобы избежать конфликтов при обновлении.

== Удаление данных
Удалить документ можно DELETE-запросом::
[source,sh]
----
DELETE movies/_doc/1
----
При удалении значение `_version` увеличивается.
Если документ будет добавлен снова, его версия продолжит расти.
Это связано с тем, что OpenSearch удаляет только `_source` документа, но сохраняет его метаданные.

== Следующие шаги

Плагин *Index Management (IM)* позволяет автоматизировать управление индексами. Подробнее: <<index-state-management>>.

Для переиндексации данных см. <<reindex-data>>.
