= Управление индексами

Вы индексируете данные с помощью REST API OpenSearch.
Существуют два вида API: `index API` и `_bulk API`.

В случае, когда новые данные поступают постепенно (например, заказы клиентов в малом бизнесе), можно использовать `index API` для добавления документов по отдельности.
Если поток данных менее частый (например, еженедельные обновления маркетингового сайта), предпочтительнее сгенерировать файл и отправить его в `_bulk API`.
Использование `_bulk API` при индексации большого количества документов обеспечивает лучшую производительность.
Если документы большого объема, то придется индексировать их по одному.

[NOTE]
====
При индексации документов их идентификатор `_id` должен быть размером не более 512 байтов.
====

== Введение в индексацию

Перед выполнением поиска данных их необходимо проиндексировать.Индексация — это метод, с помощью которого поисковые системы организуют данные для быстрого поиска.
Полученная структура называется **индексом**.

В OpenSearch основной единицей данных является JSON-документ.
Внутри индекса OpenSearch идентифицирует каждый документ с помощью уникального идентификатора.

Пример запроса к API индексации:
[source,sh]
----
PUT <index>/_doc/<id>
{
  "A JSON": "document"
}
----

Пример запроса к _bulk API:
[source,sh]
----
POST _bulk
{ "index": { "_index": "<index>", "_id": "<id>" } }
{ "A JSON": "document" }
----

=== Формат Bulk-данных
Данные для `_bulk API` должны соответствовать определённому формату, где каждая строка заканчивается символом новой строки (`\n`).
```
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
```

[NOTE]
====
Документ является необязательным, поскольку операции `delete` не требуют документа.
Остальные операции (`index`, `create` и `update`) требуют документа.
Если вы хотите, чтобы операция завершалась с ошибкой, если документ уже существует, используйте действие `create` вместо `index`.
====

Чтобы индексировать bulk-данные с помощью команды `curl`, перейдите в папку, где сохранен ваш файл, и выполните следующую команду:

```sh
curl -H "Content-Type: application/x-ndjson" -POST https://localhost:9200/data/_bulk -u 'admin:admin' --insecure --data-binary "@data.json"
```

Если какая-либо из операций в `_bulk API` завершится ошибкой, OpenSearch продолжит выполнение остальных операций.
Проверьте `items` в ответе, чтобы определить, что пошло не так.
Записи `items` соответствуют порядку операций в запросе.

OpenSearch автоматически создает индекс при добавлении документа в несуществующий индекс.
Также автоматически генерируется ID, если он не указан в запросе.
Этот простой пример автоматически создает индекс `movies`, индексирует документ и присваивает ему уникальный ID:

```sh
POST movies/_doc
{ "title": "Spirited Away" }
```

Автоматическая генерация ID имеет недостаток: поскольку в запросе индексирования не указан ID документа, его будет сложно обновить в будущем. Кроме того, если выполнить этот запрос 10 раз, OpenSearch проиндексирует документ 10 раз с разными уникальными ID.
Чтобы указать ID `1`, используйте следующий запрос:

[NOTE]
====
Обратите внимание на использование `PUT` вместо `POST`
====

```sh
PUT movies/_doc/1
{ "title": "Spirited Away" }
```

Если выполнить этот запрос 10 раз,необходимо указать ID, так как индексе останется только один документ, а поле `_version` увеличится до 10.
=== Настройки шардирования и репликации

По умолчанию индекс содержит один основной шард и одну реплику. Если вы хотите задать нестандартные настройки, создайте индекс перед добавлением документов:

```sh
PUT more-movies
{ "settings": { "number_of_shards": 6, "number_of_replicas": 2 } }
```

=== Ограничения наименования индексов

OpenSearch накладывает следующие ограничения на названия индексов:

- Все буквы должны быть в нижнем регистре.
- Название индекса не может начинаться с `_` или `-`.
- Название индекса не может содержать пробелы, запятые и следующие символы: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`.

== Чтение данных

После индексации документа его можно получить с помощью `GET`-запроса:
[source,sh]
----
GET movies/_doc/1
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Spirited Away"
  }
}
----

Ответ содержит документ в объекте `_source`.
Если документ не найден, то найденный ключ является ложным, а объект `_source` не является частью ответа.

Чтобы получить несколько документов с помощью одной команды, используйте `_mget`.
Формат для получения нескольких документов аналогичен операции `_bulk`, где вы должны указать индекс и идентификатор в запросе:
[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>"
    },
    {
      "_index": "<index>",
      "_id": "<id>"
    }
  ]
}
----

Чтобы вернуть только определенные поля в документе:
[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field1"
    },
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field2"
    }
  ]
}
----

Чтобы проверить, существует ли документ:
[source,sh]
----
HEAD movies/_doc/<doc-id>
----
Если документ существует, вернётся `200 OK`, иначе `404 Not Found`.

== Обновление данных

Чтобы обновить существующие поля или добавить новые, отправьте запрос POST на  `_update` с вашими изменениями в объекте doc:
[source,sh]
----
POST movies/_update/1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Обратите внимание на обновленное поле названия и новое поле жанра:
[source,sh]
----
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 2,
  "_seq_no" : 1,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Castle in the Sky",
    "genre" : [
      "Animation",
      "Fantasy"
    ]
  }
}
----
Документ также имеет увеличенное поле `_version`.
Используйте это поле, чтобы отслеживать, сколько раз обновлялся документ.

Запросы POST выполняют частичные обновления документов.
Чтобы полностью заменить документ, используйте запрос PUT:
[source,sh]
----
PUT movies/_doc/1
{
  "title": "Spirited Away"
}
----
Документ с идентификатором 1 будет содержать только поле `title``, поскольку весь документ будет заменен на документ, индексированный в этом запросе PUT.

Используйте `upsert` для условного обновления документов на основе того, существуют ли они уже.
Если документ существует, его поле `title` меняется на `Castle in the Sky`.
Если нет, OpenSearch индексирует документ в `upsert`.
[source,sh]
----
POST movies/_update/2
{
  "doc": {
    "title": "Castle in the Sky"
  },
  "upsert": {
    "title": "Only Yesterday",
    "genre": ["Animation", "Fantasy"],
    "date": 1993
  }
}
----
==== Пример ответа
[source,sh]
----
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "2",
  "_version" : 2,
  "result" : "updated",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 3,
  "_primary_term" : 1
}
----

Каждая операция обновления для документа имеет уникальную комбинацию значений `_seq_no` и `_primary_term`.

OpenSearch сначала записывает ваши обновления в основной шард, а затем отправляет это изменение во все шарды-реплики.
Необычная проблема может возникнуть, если несколько пользователей вашего приложения на основе OpenSearch вносят обновления в существующие документы в одном индексе.
В этой ситуации другой пользователь может прочитать и обновить документ из реплики, прежде чем он получит ваше обновление из основного шарда.
Затем ваша операция обновления в конечном итоге приводит к обновлению старой версии документа.
В лучшем случае вы и другой пользователь вносите одинаковые изменения, и документ остается точным.
В худшем случае документ теперь содержит устаревшую информацию.

Чтобы предотвратить эту ситуацию, используйте значения `_seq_no` и `_primary_term` в заголовке запроса:
[source,sh]
----
POST movies/_update/2?if_seq_no=3&if_primary_term=1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Если документ обновляется после того, как мы его извлекли, значения `_seq_no` и `_primary_term` различаются, и наша операция обновления завершается ошибкой 409 — `conflict`.

При использовании `API _bulk` укажите значения `_seq_no` и `_primary_term` в метаданных действия.

== Удаление данных
При удалении документа из индекса используйе `DELETE`:
[source,sh]
----
DELETE movies/_doc/1
----
Операция DELETE увеличивает поле `_version`.
Если вы добавляете документ обратно к тому же идентификатору, поле `_version` снова увеличивается.
Это происходит потому, что OpenSearch удаляет `_source` документа, но сохраняет его метаданные.

== Следующие шаги

Плагин *Index Management (IM)* позволяет автоматизировать управление индексами. Подробнее: <<index-state-management>>.

Для переиндексации данных см. <<reindex-data>>.
