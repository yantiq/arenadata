= Управление индексами

Вы можете индексировать данные в OpenSearch с помощью REST API.
Существует два способа индексации:

`index API` — подходит, когда данные поступают постепенно (например, заказы клиентов в малом бизнесе).
В этом случае документы добавляются по одному.

`_bulk API` — используется для пакетной индексации, что обеспечивает лучшую производительность при обработке большого количества данных.

Если документы слишком объемные, их придется индексировать по отдельности.

[NOTE]
====
При индексации документов их идентификатор `_id` не должен превышать 512 байтов.
====

== Введение в индексацию

Перед поиском данные необходимо проиндексировать.
Индексация — это процесс организации данных, благодаря которому поиск становится быстрым и эффективным.
В OpenSearch данные хранятся в виде JSON-документов, а каждый документ получает уникальный идентификатор внутри индекса.

Пример API запроса:

[source,sh]
----
PUT <index>/_doc/<id>
{ "A JSON": "document" }
----

Пример запроса `_bulk API`:

[source,sh]
----
POST _bulk
{ "index": { "_index": "<index>", "_id": "<id>" } }
{ "A JSON": "document" }
----

=== Формат данных для `_bulk API`

Данные должны быть в определенном формате: каждая строка заканчивается символом новой строки (`\n`).
```
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
```

[NOTE]
====
Документ является необязательным, так как операция `delete` его не требует. Для `index`, `create` и `update` документ обязателен.
Если нужно избежать перезаписи существующего документа, используйте `create` вместо `index`.
====
Чтобы загрузить bulk-данные через `curl`, перейдите в папку, где сохранен ваш файл, выполните команду:

```sh
curl -H "Content-Type: application/x-ndjson" -POST https://localhost:9200/data/_bulk -u 'admin:admin' --insecure --data-binary "@data.json"
```

Если одна из операций в `_bulk API` завершится с ошибкой, OpenSearch продолжит выполнение остальных.
В ответе нужно проверить `items`, чтобы выяснить причину ошибки.

=== Автоматическое создание индекса

Если индекс не существует, OpenSearch создаст его автоматически при добавлении первого документа. Также автоматически генерируется ID, если его не указать.

Этот простой пример автоматически создает индекс `movies`, индексирует документ и присваивает ему уникальный ID:

```sh
POST movies/_doc
{ "title": "Spirited Away" }
```

Если ID не указан, документ сложно обновить в будущем, а при повторном выполнении запроса создаются дубликаты.

Пример указания ID `1`:

[NOTE]
====
Обратите внимание на использование `PUT` вместо `POST`
====

```sh
PUT movies/_doc/1
{ "title": "Spirited Away" }
```

Если запрос выполнить 10 раз, сохранится один документ, а его поле `_version` увеличится до 10.

=== Настройки шардирования и репликации

По умолчанию у индекса 1 основной шард и 1 реплика.
Чтобы задать другие параметры, создайте индекс перед добавлением данных:

```sh
PUT more-movies
{ "settings": { "number_of_shards": 6, "number_of_replicas": 2 } }
```

=== Ограничения наименования индексов

OpenSearch накладывает следующие ограничения на названия индексов:

- Все буквы должны быть в нижнем регистре.
- Название индекса не может начинаться с `_` или `-`.
- Название индекса не может содержать пробелы, запятые и следующие символы: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`.

== Чтение данных

Чтобы получить документ по ID, выполните GET-запрос:

[source,sh]
----
GET movies/_doc/1
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Spirited Away"
  }
}
----

Ответ содержит документ в объекте `_source`.
Если документ отсутствует, поле `found` будет *false*.
Для получения нескольких документов используйте `_mget`:

[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>"
    },
    {
      "_index": "<index>",
      "_id": "<id>"
    }
  ]
}
----

Чтобы вернуть только определенные поля в документе:

[source,sh]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field1"
    },
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field2"
    }
  ]
}
----

Чтобы проверить существование документа:

[source,sh]
----
HEAD movies/_doc/<doc-id>
----
Если документ существует, вернётся `200 OK`, иначе `404 Not Found`.

== Обновление данных

Частичное обновление документа выполняется с помощью `_update`:

[source,sh]
----
POST movies/_update/1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Обратите внимание на обновленное поле названия и новое поле жанра:
[source,sh]
----
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 2,
  "_seq_no" : 1,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Castle in the Sky",
    "genre" : [
      "Animation",
      "Fantasy"
    ]
  }
}
----
Документ также имеет увеличенное поле `_version`.
Используйте это поле, чтобы отслеживать, сколько раз обновлялся документ.

Полное обновление документа выполняется PUT-запросом:
[source,sh]
----
PUT movies/_doc/1
{ 
  "title": "Spirited Away" 
}
----
Документ с идентификатором 1 будет содержать только поле `title``, поскольку весь документ будет заменен на документ, индексированный в этом запросе PUT.

Если документ отсутствует, его можно создать с помощью `upsert`:
Если документ существует, его поле `title` меняется на `Castle in the Sky`.
Если нет, OpenSearch индексирует документ в `upsert`.

[source,sh]
----
POST movies/_update/2
{
  "doc": {
    "title": "Castle in the Sky"
  },
  "upsert": {
    "title": "Only Yesterday",
    "genre": ["Animation", "Fantasy"],
    "date": 1993
  }
}
----
==== Пример ответа

[source,sh]
----
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "2",
  "_version" : 2,
  "result" : "updated",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 3,
  "_primary_term" : 1
}
----

Каждая операция обновления для документа имеет уникальную комбинацию значений `_seq_no` и `_primary_term`.

OpenSearch сначала записывает ваши обновления в основной шард, а затем отправляет это изменение во все шарды-реплики.
Необычная проблема может возникнуть, если несколько пользователей вашего приложения на основе OpenSearch вносят обновления в существующие документы в одном индексе.
В этой ситуации другой пользователь может прочитать и обновить документ из реплики, прежде чем он получит ваше обновление из основного шарда.
Затем ваша операция обновления в конечном итоге приводит к обновлению старой версии документа.
В лучшем случае вы и другой пользователь вносите одинаковые изменения, и документ остается точным.
В худшем случае документ теперь содержит устаревшую информацию.

Чтобы предотвратить эту ситуацию, используйте значения `_seq_no` и `_primary_term` в заголовке запроса:
[source,sh]
----
POST movies/_update/2?if_seq_no=3&if_primary_term=1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----
Если документ обновляется после того, как мы его извлекли, значения `_seq_no` и `_primary_term` различаются, и наша операция обновления завершается ошибкой 409 — `conflict`.

При использовании `API _bulk` укажите значения `_seq_no` и `_primary_term` в метаданных действия.

== Удаление данных
Удалить документ можно DELETE-запросом::
[source,sh]
----
DELETE movies/_doc/1
----
Поле `_version` при этом увеличится, а если документ будет снова добавлен, его версия продолжит расти.
Это происходит потому, что OpenSearch удаляет `_source` документа, но сохраняет его метаданные.

== Следующие шаги

Плагин *Index Management (IM)* позволяет автоматизировать управление индексами. Подробнее: <<index-state-management>>.

Для переиндексации данных см. <<reindex-data>>.
